{"version":3,"sources":["main.js"],"names":["container","document","getElementById","body","appendChild","renderer","THREE","WebGLRenderer","setSize","window","innerWidth","innerHeight","domElement","scene","Scene","camera","PerspectiveCamera","geometry","SphereGeometry","material","MeshPhongMaterial","texture","TextureLoader","load","minFilter","NearestFilter","map","bump","bumpMap","bumpScale","sphere","Mesh","add","camera_radius","start_pos","Vector3","current_pos","y_vector","z_vector","light","PointLight","animate","requestAnimationFrame","position","set","x","y","z","lookAt","render","rotateVector","newLat","newLong","applyAxisAngle","Math","PI","long","lat"],"mappings":";AAAA,IAAIA,EAAYC,SAASC,eAAe,aACxCD,SAASE,KAAKC,YAAYJ,GAE1B,IAAIK,EAAW,IAAIC,MAAMC,cACzBF,EAASG,QAASC,OAAOC,WAAYD,OAAOE,aAC5CX,EAAUI,YAAaC,EAASO,YAGhC,IAAIC,EAAQ,IAAIP,MAAMQ,MAMlBC,EAAS,IAAIT,MAAMU,kBAAmB,GAAIP,OAAOC,WAAaD,OAAOE,YAAa,GAAK,IAGvFM,EAAW,IAAIX,MAAMY,eAAgB,EAAG,GAAI,IAC5CC,EAAW,IAAIb,MAAMc,kBAKrBC,GAAU,IAAIf,MAAMgB,eAAgBC,KAAK,4CAI7CF,EAAQG,UAAYlB,MAAMmB,cAG1BN,EAASO,IAAML,EAGf,IAAIM,GAAO,IAAIrB,MAAMgB,eAAgBC,KAAK,4CAE1CJ,EAASS,QAAUD,EACnBR,EAASU,UAAY,GAIrB,IAAIC,EAAS,IAAIxB,MAAMyB,KAAMd,EAAUE,GAEvCN,EAAMmB,IAAKF,GAKXG,cAAgB,EAMhBC,UAAY,IAAI5B,MAAM6B,QAAQF,cAAc,EAAE,GAC9CG,YAAc,IAAI9B,MAAM6B,QAAQF,cAAc,EAAE,GAGhDI,SAAW,IAAI/B,MAAM6B,QAAQ,EAAE,EAAE,GACjCG,SAAW,IAAIhC,MAAM6B,QAAQ,EAAE,EAAE,GAIjC,IAAII,EAAQ,IAAIjC,MAAMkC,WAAY,UAWlC,SAASC,IACRC,sBAAuBD,GAEvB1B,EAAO4B,SAASC,IAAIR,YAAYS,EAAGT,YAAYU,EAAGV,YAAYW,GAE9DR,EAAMI,SAASC,IAAK7B,EAAO4B,SAASE,EAAG9B,EAAO4B,SAASG,EAAG/B,EAAO4B,SAASI,GAG1EhC,EAAOiC,OAAO,IAAI1C,MAAM6B,SACxB9B,EAAS4C,OAAQpC,EAAOE,GAMzB,SAASmC,EAAaC,EAAQC,GAG7BlB,UAAUmB,eAAehB,SAAUe,EAAUE,KAAKC,GAAK,KAAKF,eAAef,SAAUa,EAASG,KAAKC,GAAK,KAExGnB,YAAYQ,IAAIV,UAAUW,EAAGX,UAAUY,EAAGZ,UAAUa,GAEpDb,UAAUmB,eAAehB,UAAW,EAAIe,EAAUE,KAAKC,GAAK,KAAKF,eAAef,UAAW,EAAIa,EAASG,KAAKC,GAAK,KAhCnH1C,EAAMmB,IAAIO,GAIViB,KAAO,EACPC,IAAM,EAGNP,EAAaM,KAAMC,KAanBhB","file":"main.c89207c1.js","sourceRoot":"..","sourcesContent":["var container = document.getElementById('moonglobe');\r\ndocument.body.appendChild(container);\r\n\r\nvar renderer = new THREE.WebGLRenderer();\r\nrenderer.setSize( window.innerWidth, window.innerHeight);\r\ncontainer.appendChild( renderer.domElement );\r\n\r\n//add scene\r\nvar scene = new THREE.Scene();\r\n\r\n//add camera\r\n// FOV: 75 degrees\r\n// Aspect: width/height\r\n// clipping: close, far\r\nvar camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10 );\r\n\r\n\r\nvar geometry = new THREE.SphereGeometry( 5, 32, 32 );\r\nvar material = new THREE.MeshPhongMaterial();\r\n\r\n//create texture based on image\r\n// using cropped jpg\r\n// removed 9 pixels from left and right side\r\nvar texture = new THREE.TextureLoader().load('img/LRO_WAC_Mosaic_Global_50ppd_crop.jpg');\r\n\r\n// add filter to reduce pinch at poles\r\n// not ideal but quick fix for now\r\ntexture.minFilter = THREE.NearestFilter;\r\n\r\n// map texture to material object\r\nmaterial.map = texture;\r\n\r\n// load bumpmap image\r\nvar bump = new THREE.TextureLoader().load('img/LRO_WAC_Mosaic_Global_50ppd_bump.jpg');\r\n// add bumpmap to material object\r\nmaterial.bumpMap = bump;\r\nmaterial.bumpScale = 0.2;\r\n\r\n\r\n// create mesh based on geometry and material\r\nvar sphere = new THREE.Mesh( geometry, material );\r\n// add mesh to scene\r\nscene.add( sphere );\r\n\r\n\r\n// set camera distance\r\n// *NOTE: Should be greater than sphere/object radius\r\ncamera_radius = 9;\r\n\r\n// Vectors in 3D space\r\n// we will use these during camera rotation\r\n// start_pos will be the default position for our camera\r\n// current_pos will be updated position of camera\r\nstart_pos = new THREE.Vector3(camera_radius,0,0);\r\ncurrent_pos = new THREE.Vector3(camera_radius,0,0);\r\n\r\n// we will use these vectors when applying rotations to camera\r\ny_vector = new THREE.Vector3(0,1,0);\r\nz_vector = new THREE.Vector3(0,0,1);\r\n\r\n\r\n// add light source(s)\r\nvar light = new THREE.PointLight( 0xffffff );\r\nscene.add(light);\r\n\r\n\r\n// add longtitude and latitude vars\r\nlong = 0;\r\nlat = 0;\r\n\r\n// call this to set camera location to default\r\nrotateVector(long, lat);\r\n\r\nfunction animate() {\r\n\trequestAnimationFrame( animate );\r\n\t// set camera location to current_pos vector components\r\n\tcamera.position.set(current_pos.x, current_pos.y, current_pos.z);\r\n\t// place light source to camera location\r\n\tlight.position.set( camera.position.x, camera.position.y, camera.position.z);\r\n\t// point camera to moon\r\n\t// moon is at (0,0,0)\r\n\tcamera.lookAt(new THREE.Vector3());\r\n\trenderer.render( scene, camera );\r\n}\r\nanimate();\r\n\r\n// newLong: float value representing longitude [-180,180]\r\n// newLat: float value representing latitude [-90,90]\r\nfunction rotateVector(newLat, newLong) {\r\n\t// apply rotation transformations to default vector\r\n\t// we do this as our default vector points toward (0, 0) in (latitude, longitude)\r\n\tstart_pos.applyAxisAngle(y_vector, newLong * Math.PI / 180).applyAxisAngle(z_vector, newLat * Math.PI / 180);\r\n\t// assign x,y,z components to current_pos vector\r\n\tcurrent_pos.set(start_pos.x, start_pos.y, start_pos.z);\r\n\t// undo rotations to default vector\r\n\tstart_pos.applyAxisAngle(y_vector, -1 * newLong * Math.PI / 180).applyAxisAngle(z_vector, -1 * newLat * Math.PI / 180);\r\n}"]}